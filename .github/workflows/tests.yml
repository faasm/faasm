name: Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review]

defaults:
  run:
    shell: bash

jobs:
  # Cancel previous running actions for the same PR
  cancel_previous:
    runs-on: ubuntu-latest
    steps:
      - name: Cancel Workflow Action
        uses: styfle/cancel-workflow-action@0.11.0

  checks:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    container:
      image: faasm.azurecr.io/cli:0.9.9
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v3
        with:
          submodules: true
          fetch-depth: 0
        # We need to set the safe git directory as formatting relies on git-ls
        # See actions/checkout#766
      - name: "Set the GH workspace as a safe git directory"
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git config --global --add safe.directory "$GITHUB_WORKSPACE/faabric"
          git config --global --add safe.directory "$GITHUB_WORKSPACE/cpp"
          git config --global --add safe.directory "$GITHUB_WORKSPACE/python"
      # Formatting checks
      - name: "Code formatting check"
        run: ./bin/inv_wrapper.sh format-code --check
      # Sanity checks
      - name: "Check that all the submodules point to their 'main' branch"
        run: ./bin/inv_wrapper.sh git.check-submodule-branch

  docs:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    container:
      image: faasm.azurecr.io/cli:0.9.9
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v3
        with:
          submodules: true
      - name: "Build docs"
        run: ./bin/inv_wrapper.sh docs

  cpp-funcs:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    container:
      image: faasm.azurecr.io/cpp-sysroot:0.2.7
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v3
        with:
          submodules: recursive
      - name: "Build C++ functions"
        run: ./bin/inv_wrapper.sh func.local
        working-directory: ${{ github.workspace }}/clients/cpp
      - name: "Build libfake"
        run: ./bin/inv_wrapper.sh libfake
        working-directory: ${{ github.workspace }}/clients/cpp
      - name: "Build libfake"
        run: ./bin/inv_wrapper.sh libfake
        working-directory: ${{ github.workspace }}/clients/cpp
      - name: "Upload cpp wasm"
        uses: actions/upload-artifact@v3.1.0
        with:
          name: cpp-wasm
          path: /usr/local/faasm/wasm
      - name: "Upload fake lib wasm"
        uses: actions/upload-artifact@v3.1.0
        with:
          name: libfake-wasm
          path: /usr/local/faasm/runtime_root/lib/fake

  py-funcs:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    container:
      image: faasm.azurecr.io/cpython:0.2.5
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v3
        with:
          submodules: recursive
      - name: "Build CPython function"
        run: ./bin/inv_wrapper.sh cpython.func
        working-directory: ${{ github.workspace }}/clients/python
      - name: "Put Python functions in place"
        run: ./bin/inv_wrapper.sh func.upload-all --local
        working-directory: ${{ github.workspace }}/clients/python
      - name: "Upload python wasm"
        uses: actions/upload-artifact@v3.1.0
        with:
          name: py-wasm
          path: /usr/local/faasm/wasm/python
      - name: "Upload python functions"
        uses: actions/upload-artifact@v3.1.0
        with:
          name: py-funcs
          path: /usr/local/faasm/shared

  conan-cache:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    container:
      image: faasm.azurecr.io/cli:0.9.9
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    steps:
      - name: "Conan cache"
        uses: faasm/conan-cache-action@v1
      - name: "Build Conan dependencies to be shared by all runs"
        run: ./bin/inv_wrapper.sh dev.cmake --build Debug --clean
      - name: "Build codegen without sanitisers for all test runs"
        run: ./bin/inv_wrapper.sh dev.cc codegen_func dev.cc codegen_shared_obj
      - name: "Upload codegen binaries"
        uses: actions/upload-artifact@v3.1.0
        with:
          name: codegen-bin
          path: /build/faasm/bin

  code-coverage:
    if: github.event.pull_request.draft == false
    needs: [cpp-funcs, py-funcs, conan-cache]
    runs-on: ubuntu-latest
    env:
      CGROUP_MODE: off
      HOST_TYPE: ci
      LOG_LEVEL: info
      NETNS_MODE: off
      PLANNER_HOST: planner
      PLANNER_PORT: 8080
      REDIS_QUEUE_HOST: redis
      REDIS_STATE_HOST: redis
    container:
      image: faasm.azurecr.io/cli:0.9.9
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    services:
      redis:
        image: faasm.azurecr.io/redis:0.9.9
        credentials:
          username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
          password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
      minio:
        image: faasm.azurecr.io/minio:0.9.9
        credentials:
          username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
          password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
        env:
          MINIO_ROOT_USER: minio
          MINIO_ROOT_PASSWORD: minio123
      planner:
        image: faasm.azurecr.io/planner:0.4.4
    steps:
      - uses: faasm/conan-cache-action@v1
      - name: "Ping redis"
        run: redis-cli -h redis ping
      - name: "Ping minio"
        run: curl -f http://minio:9000/minio/health/live
      # Download wasm generated by previous steps
      - name: "Download CPP wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: cpp-wasm
          path: /usr/local/faasm/wasm
      - name: "Download libfake wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: libfake-wasm
          path: /usr/local/faasm/runtime_root/lib/fake
      - name: "Download Python wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: py-wasm
          path: /usr/local/faasm/wasm/python
      - name: "Download Python funcs"
        uses: actions/download-artifact@v3.0.1
        with:
          name: py-funcs
          path: /usr/local/faasm/shared
      # Cache contains architecture-specific machine code
      - name: "CPU info"
        run: cat /proc/cpuinfo
      - name: "Get CPU model name"
        run: echo "CPU_MODEL=$(./bin/print_cpu.sh)" >> $GITHUB_ENV
      - name: "Print CPU model"
        run: echo "${{ env.CPU_MODEL}}"
      - name: "Configure machine code cache"
        uses: actions/cache@v3.0.11
        with:
          path: /usr/local/faasm/object
          key: ${{ env.CPU_MODEL }}-machine-code-${{ secrets.CACHE_VERSION }}
      - name: "Download codegen binaries shared between test runs"
        uses: actions/download-artifact@v3.0.1
        with:
          name: codegen-bin
          path: /build/faasm/bin
      # Code build with coverage
      - name: "Build dev tools with code coverage"
        run: ./bin/inv_wrapper.sh dev.tools --build Debug --clean --coverage
      # Environment set-up
      - name: "Run codegen for the tests"
        run: ./bin/inv_wrapper.sh codegen.tests
      - name: "Clear existing pyc files"
        run: ./bin/inv_wrapper.sh python.clear-runtime-pyc
      # Test run
      - name: "Run the tests"
        run: /build/faasm/bin/tests
        env:
          LLVM_PROFILE_FILE: faasm.profraw
      - name: "Generate code coverage report"
        run: ./bin/inv_wrapper.sh dev.coverage-report --file-in faasm.profraw --file-out coverage.txt
      - name: "Upload coverage report to CodeCov"
        uses: codecov/codecov-action@v3
        with:
          # Note that this secret is specific to this repository
          token: ${{ secrets.CODECOV_TOKEN }}

  tests:
    if: github.event.pull_request.draft == false
    needs: [cpp-funcs, py-funcs, conan-cache]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        sanitiser: [None, Address, Thread, Undefined]
    env:
      HOST_TYPE: ci
    container:
      image: faasm.azurecr.io/cli:0.9.9
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    services:
      redis:
        image: faasm.azurecr.io/redis:0.9.9
        credentials:
          username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
          password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
      minio:
        image: faasm.azurecr.io/minio:0.9.9
        credentials:
          username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
          password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
        env:
          MINIO_ROOT_USER: minio
          MINIO_ROOT_PASSWORD: minio123
      planner:
        image: faasm.azurecr.io/planner:0.4.4
    steps:
      - name: "Conan cache"
        uses: faasm/conan-cache-action@v1
      - name: "Ping redis"
        run: redis-cli -h redis ping
      - name: "Ping minio"
        run: curl -f http://minio:9000/minio/health/live
      # Download wasm generated by previous steps
      - name: "Download CPP wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: cpp-wasm
          path: /usr/local/faasm/wasm
      - name: "Download libfake wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: libfake-wasm
          path: /usr/local/faasm/runtime_root/lib/fake
      - name: "Download Python wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: py-wasm
          path: /usr/local/faasm/wasm/python
      - name: "Download Python funcs"
        uses: actions/download-artifact@v3.0.1
        with:
          name: py-funcs
          path: /usr/local/faasm/shared
      # Cache contains architecture-specific machine code
      - name: "CPU info"
        run: cat /proc/cpuinfo
      - name: "Get CPU model name"
        run: echo "CPU_MODEL=$(./bin/print_cpu.sh)" >> $GITHUB_ENV
      - name: "Print CPU model"
        run: echo "${{ env.CPU_MODEL}}"
      - name: "Configure machine code cache"
        uses: actions/cache@v3.0.11
        with:
          path: /usr/local/faasm/object
          key: ${{ env.CPU_MODEL }}-machine-code-${{ secrets.CACHE_VERSION }}
      - name: "Download codegen binaries shared between test runs"
        uses: actions/download-artifact@v3.0.1
        with:
          name: codegen-bin
          path: /build/faasm/bin
      # Environment set-up
      - name: "Run codegen for the tests"
        run: ./bin/inv_wrapper.sh codegen.tests
      - name: "Clear existing pyc files"
        run: ./bin/inv_wrapper.sh python.clear-runtime-pyc
      # Tests build (Debug required for tests)
      - name: "Re-run CMake with sanitiser set"
        run: ./bin/inv_wrapper.sh dev.cmake --clean --build Debug --sanitiser ${{ matrix.sanitiser }}
      - name: "Build only the tests target"
        run: ./bin/inv_wrapper.sh dev.cc tests
      # Run tests
      - name: "Run the tests"
        # TODO: temporarily run in abort, to see if we are missing any env. vars
        run: ./bin/inv_wrapper.sh tests

  sgx-tests:
    if: github.event.pull_request.draft == false
    needs: [cpp-funcs, py-funcs, conan-cache]
    runs-on: ubuntu-latest
    env:
      HOST_TYPE: ci
    container:
      image: faasm.azurecr.io/cli-sgx-sim:0.9.9
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    services:
      redis:
        image: faasm.azurecr.io/redis:0.9.9
        credentials:
          username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
          password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
      minio:
        image: faasm.azurecr.io/minio:0.9.9
        credentials:
          username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
          password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
        env:
          MINIO_ROOT_USER: minio
          MINIO_ROOT_PASSWORD: minio123
      planner:
        image: faasm.azurecr.io/planner:0.4.4
    steps:
      - name: "Conan cache"
        uses: faasm/conan-cache-action@v1
      - name: "Ping redis"
        run: redis-cli -h redis ping
      - name: "Ping minio"
        run: curl -f http://minio:9000/minio/health/live
      # Download wasm generated by previous steps
      - name: "Download CPP wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: cpp-wasm
          path: /usr/local/faasm/wasm
      - name: "Download libfake wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: libfake-wasm
          path: /usr/local/faasm/runtime_root/lib/fake
      - name: "Download Python wasm"
        uses: actions/download-artifact@v3.0.1
        with:
          name: py-wasm
          path: /usr/local/faasm/wasm/python
      - name: "Download Python funcs"
        uses: actions/download-artifact@v3.0.1
        with:
          name: py-funcs
          path: /usr/local/faasm/shared
      # Cache contains architecture-specific machine code
      - name: "CPU info"
        run: cat /proc/cpuinfo
      - name: "Get CPU model name"
        run: echo "CPU_MODEL=$(./bin/print_cpu.sh)" >> $GITHUB_ENV
      - name: "Print CPU model"
        run: echo "${{ env.CPU_MODEL}}"
      - name: "Configure machine code cache"
        uses: actions/cache@v3.0.11
        with:
          path: /usr/local/faasm/object
          key: ${{ env.CPU_MODEL }}-machine-code-${{ secrets.CACHE_VERSION }}
      # Code build (Debug required for tests)
      - name: "Build dev tools"
        run: ./bin/inv_wrapper.sh dev.tools --build Debug --sgx Simulation --clean
      # Environment set-up
      - name: "Run codegen for the tests"
        run: ./bin/inv_wrapper.sh codegen.tests
      - name: "Clear existing pyc files"
        run: ./bin/inv_wrapper.sh python.clear-runtime-pyc
      # Test run
      - name: "Run the tests"
        run: ./bin/inv_wrapper.sh tests

  dist-tests:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    strategy:
      matrix:
        wasm_vm: [wamr, wavm]
    env:
      CONAN_CACHE_MOUNT_SOURCE: ~/.conan
      WASM_VM: ${{ matrix.wasm_vm }}
    steps:
      - name: "Check out code"
        uses: actions/checkout@v3
        with:
          submodules: true
      - name: "Conan cache"
        uses: faasm/conan-cache-action@v1
      # Cache contains architecture-specific machine code
      - name: "Get CPU model name"
        run: echo "CPU_MODEL=$(./bin/print_cpu.sh)" >> $GITHUB_ENV
      - name: "Print CPU model"
        run: echo "${{ env.CPU_MODEL}}"
      - name: "Configure S3 cache"
        uses: actions/cache@v3.0.11
        with:
          path: ./dev/minio/data/faasm
          key: ${{ env.CPU_MODEL }}-s3-data-${{ secrets.CACHE_VERSION }}
      - name: "Build tests"
        run: ./deploy/dist-test/build.sh
      - name: "Get the planner logs"
        run: |
          docker compose logs planner
      - name: "Build and upload functions for tests"
        run: ./deploy/dist-test/upload.sh
      - name: "Run tests"
        run: ./deploy/dist-test/run.sh

  quick-start:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        detached: [true, false]
    defaults:
      run:
        working-directory: ${{ github.workspace }}
    env:
      PYTHON_CODEGEN: "on"
    steps:
      - name: "Checkout code and set conan cache"
        uses: faasm/conan-cache-action@v1
        with:
          build-type: release
      - name: "Fetch python's CPP submodulle"
        run: git submodule update --init -f third-party/cpp
        working-directory: ${{ github.workspace }}/clients/python
      # Cache contains architecture-specific machine code
      - name: "Get CPU model name"
        run: echo "CPU_MODEL=$(./bin/print_cpu.sh)" >> $GITHUB_ENV
      - name: "Print CPU model"
        run: echo "${{ env.CPU_MODEL}}"
      - name: "Configure S3 cache"
        uses: actions/cache@v3.0.11
        with:
          path: ./dev/minio/data/faasm
          key: ${{ env.CPU_MODEL }}-s3-data-${{ secrets.CACHE_VERSION }}
      # Setup
      - name: "Populate the runtime sysroot if non-dettached"
        run: |
          [[ "${{ matrix.detached }}" == "false" ]] && ./bin/refresh_local.sh || exit 0
      - name: "Start docker compose"
        run: |
          [[ "${{ matrix.detached }}" == "false" ]] && export \
            FAASM_BUILD_MOUNT=/build/faasm \
            FAASM_CODE_MOUNT=/usr/local/code/faasm \
            FAASM_CONAN_MOUNT=/root/.conan \
            FAASM_LOCAL_MOUNT=/usr/local/faasm
          docker compose up -d --scale worker=2 nginx faasm-cli
        env:
          PLANNER_BUILD_MOUNT: /build/faabric/static
      # We only need to wait if we are mounting the code into the container,
      # as then the container's `venv` will be overwritten by the host's code
      # version (without venv)
      - name: "Wait for CLI to be ready"
        run: |
          [[ "${{ matrix.detached }}" == "false" ]] && ./bin/wait_for_venv.sh || exit 0
        env:
          FAASM_DOCKER: "on"
      - name: "Re-build targets if necessary"
        run: docker compose exec faasm-cli ./bin/inv_wrapper.sh dev.tools --build Release
      - name: "Re-start the services to pick up new binaries (if necessary)"
        run: docker compose restart upload worker nginx
      # This can fail when the container isn't ready, so we want to retry
      - name: "Wait for upload server to be available"
        run: |
          (echo "Attempt 1" && docker compose exec -T upload /usr/local/code/faasm/deploy/local/wait_for_upload.sh localhost 8002) || \
          (sleep 30s && echo "Attempt 2" && docker compose exec -T upload /usr/local/code/faasm/deploy/local/wait_for_upload.sh localhost 8002) || \
          (sleep 30s && echo "Attempt 3" && docker compose exec -T upload /usr/local/code/faasm/deploy/local/wait_for_upload.sh localhost 8002) || \
          (echo "Wait for upload failed after retries" && docker compose logs upload && exit 1)
      # Function upload
      - name: "Build and upload cpp function"
        run: docker compose run -T cpp ./bin/inv_wrapper.sh func demo hello func.upload demo hello
      - name: "Build and upload python function"
        run: docker compose run -T python ./bin/inv_wrapper.sh cpython.func cpython.upload func.uploadpy hello
      # Function invocation
      - name: "Invoke cpp function"
        run: |
          # Make sure we error out if the docker compose command fails. By
          # default, errors are silenced by the pipe
          set -o pipefail
          docker compose run -T cpp ./bin/inv_wrapper.sh func.invoke demo hello | tee output_1.log
      - name: "Invoke python hello function"
        run: docker compose run -T python ./bin/inv_wrapper.sh func.invoke python hello
      # Re-invocation of same function with different code after flush
      - name: "Flush workers"
        run: |
          docker compose run -T cpp ./bin/inv_wrapper.sh func.flush
          # Sleep for a bit after flush to give it time to propagate (flush is
          # both asynchronous and gossip-based)
          sleep 10s
      - name: "Build echo function and upload in place of hello function"
        run: ./deploy/local/replace_hello_with_echo.sh
      - name: "Invoke same cpp function with different WASM code"
        run: |
          set -o pipefail
          docker compose run -T cpp ./bin/inv_wrapper.sh func.invoke demo hello | tee output_2.log
      - name: "Check both outputs are different"
        run: (cmp output_1.log output_2.log && exit 1 || exit 0)
      # Print logs and finish
      - name: "Unconditional docker compose cleanup"
        run: |
          docker compose logs
          docker compose down
        if: always()
