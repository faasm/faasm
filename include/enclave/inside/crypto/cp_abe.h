#pragma once

#include <cstddef>
#include <cstdint>
#include <string>
#include <vector>

// Forward-declare our context and use it as an opaque pointer. rabe will
// handle all memory management for us
struct CpAbeContext;
struct CpAbeSecretKey;
struct BufferFfi {
    uint8_t* data;
    size_t size;
};

// Function declarations for Rust functions
extern "C" {
    CpAbeContext* rabe_bsw_context_create();
    void rabe_bsw_context_destroy(CpAbeContext* ctx);

    CpAbeSecretKey* rabe_bsw_keygen(CpAbeContext* ctx, const char* attributes);
    void rabe_bsw_keygen_destroy(CpAbeSecretKey* secretKey);

    void rabe_bsw_free_buffer_ffi(BufferFfi* buffer);

    int32_t rabe_bsw_encrypt(
        CpAbeContext* ctx,
        const char* policy,
        const char* policyLanguage,
        const uint8_t* plainText,
        size_t plainTextLen,
        BufferFfi** cipherText);

    int32_t rabe_bsw_decrypt(
        CpAbeSecretKey* secretKey,
        // WARNING: cipherText must be null-terminated (consider treating it
        // as a string on C++, make sure we understand why Rabe uses it like
        // a string)
        const uint8_t* cipherText,
        BufferFfi** actualPlainText);
}

namespace sgx {

/* Context manager for Ciphertext-Policy Attribute Based Encryption using the
 * RABE library in Rust.
 */
class CpAbeContextWrapper {
public:
    static CpAbeContextWrapper& get() {
        static CpAbeContextWrapper ctx;

        /*
        bool success = ctx.fetchKeys();
        if (!success) {
            throw std::runtime_error("Error fetching keys for CP-ABE manager");
        }
        */
        ctx.createKeys();

        return ctx;
    }

    // Call the setup() procedure to generate a MasterKey and a PublicKey for
    // our CP-ABE scheme
    void createKeys();

    // Serialize the context into an array. This is useful to then upload it
    // to S3 or something (maybe not on C++ tho, Rust probs better for the CLI)
    std::vector<uint8_t> dumpKeys();

    // Fetch the context generated by a trusted authority. This will use the
    // TLS channel established during remote-attestation
    bool fetchKeys();

    // Encrypt plain-text with an access-structure over the policy. The policy is
    // a string where sub-string values are and-ed or or-ed like:
    // std::string policy = "\"A\" and \"B\"";
    std::vector<uint8_t> cpAbeEncrypt(
        const std::string& policy,
        const std::vector<uint8_t>& plainText);

    std::vector<uint8_t> cpAbeEncrypt(
        const std::string& policy,
        const std::string& plainText);

    // Decryption will succeed if the attributes pass the policy with which the
    // cipher-text was encrypted. For example, if the policy is:
    // std::string policy = "\"A\" and \"B\"";
    // then, attributes must be
    // std::vector<std::string> attributes = { "A", "B" };
    std::vector<uint8_t> cpAbeDecrypt(
        const std::vector<std::string>& attributes,
        const std::vector<uint8_t>& cipherText);

  private:
    std::string policyLanguage = "HumanPolicy";
    CpAbeContext* _ctx = nullptr;
    bool externalContext = false;

    ~CpAbeContextWrapper()
    {
        if (_ctx != nullptr) {
            if (externalContext) {
                free(_ctx);
            }
        } else {
            rabe_bsw_context_destroy(_ctx);
            _ctx = nullptr;
        }
    }
};
}
